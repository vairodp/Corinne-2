import os
import tkinter as tk
from tkinter import ttk
from tkinter import filedialog, Frame, Entry, Button, messagebox, Listbox, Radiobutton, PhotoImage, Menu

from PIL import ImageTk,Image
import pickle



class MyGui(ttk.Frame):
    controller = None
    tabs = None
    tabs_history = []
    _log = None
    _screen_width = None
    _screen_height = None
    COLOR_buttons = '#FFCB6B'
    COLOR_frames = '#333333'
    COLOR_foreground = '#D9C7B3'
    COLOR_log = '#1E1E1E'


    def v_restoreSession(self):
    	with open("saved_sessions/saved_tabs.pkl","rb") as f:
    		history = pickle.load(f)

    	for i in history:
    		self.open_file(i)

    def v_splashscreen(self,master,height,width):
        image_splash = "icons/logo-gif.gif"
        image = tk.PhotoImage(file=image_splash)
        canvas = tk.Canvas(master, height=height*0.8,width=width)
        canvas.create_image(width*0.8/2, height*0.8/2, image =image)
        canvas.grid()

        master.after(5000,master.destroy)

    def __init__(self, master, controller):
        super().__init__()
        master.protocol("WM_DELETE_WINDOW", self.v_on_closing)

        self.controller = controller
        self.v_initUi(master)

        if os.path.isfile("saved_sessions/saved_tabs.pkl"):
        	self.v_restoreSession()
        

    def v_on_closing(self):

    	close = messagebox.askyesnocancel(title="Warning", message="Do you want to save the session?")

    	if close == True:
    		picklefile = open("saved_sessions/saved_tabs.pkl","wb")
    		pickle.dump(self.tabs_history,picklefile)
    		picklefile.close()

    		self.master.destroy()

    	elif close == False:
    		if os.path.isfile("saved_sessions/saved_tabs.pkl"):
    			os.remove("saved_sessions/saved_tabs.pkl")
    		self.master.destroy()

    def dos2unix(self,file_path):
        # replacement strings
        WINDOWS_LINE_ENDING = b'\r\n'
        UNIX_LINE_ENDING = b'\n'

        with open(file_path, 'rb') as open_file:
            content = open_file.read()

        content = content.replace(WINDOWS_LINE_ENDING, UNIX_LINE_ENDING)

        with open(file_path, 'wb') as open_file:
            open_file.write(content)

    def help_window(self):
        self.top = tk.Toplevel()
        self.top.title("Usage")
        label= tk.Label(self.top,text="Open: takes in input DOT files,but can also it can get:\n"+
                                      " - Chorgram file (.txt), a grammar used for Global Graph\n"+
                                      " - DOT files (.gv) generated by Domitilla and converte them into DOT files with CA sintax\n\n\n"+
                                      "Once taken one or more files as input, Corinne can apply some functions on it:\n\n"+
                                      " - Product: a cartesian product of two CA\n"+
                                      " - Synchronization: given a CA, it can synchronize two participants of its\n"+
                                      " - Projection: given a CA, you can select one participant from it and get the relative CFSM",justify=tk.LEFT,padx=15,pady=15).pack()

    def v_initUi(self, master):
        self.master.title("Corinne 2.0")
        self.master.grid_columnconfigure(0, weight=1)
        self.master.grid_rowconfigure(2, weight=1)
        self.master.option_add('*foreground', 'black')
        self.master.option_add('*background', 'white')

        # Style for ttk widgets
        style = ttk.Style()
        style.configure("TNotebook", background=self.COLOR_frames, borderwidth=1, highlightthickness=1)
        style.configure("TNotebook.Tab", background=self.COLOR_frames, foreground="black",
                             lightcolor=self.COLOR_frames, borderwidth=0)
        style.map("TNotebook.Tab", background=[("selected", self.COLOR_buttons)],
                       foreground=[("selected", 'black')])
        style.configure("TFrame", background=self.COLOR_frames, foreground="black")

        # get screen resolution
        self._screen_width, self._screen_height = master.winfo_screenwidth(), master.winfo_screenheight()
        start_x = int((self._screen_width / 4))
        start_y = int((self._screen_height / 4))
        # fit the guy at screen resolution
        master.geometry('%dx%d+%d+%d' % (self._screen_width / 2, self._screen_height / 2, start_x, start_y))

        #self.v_splashscreen(master,start_x,start_y)
        #create all the containers
        menu_frame = Frame(master,padx=10, pady=10)
        menu_frame.grid(row=0,column=0,sticky=(tk.N, tk.S, tk.E, tk.W))
        menu_frame.configure(bg=self.COLOR_frames)
        menu_frame.grid_columnconfigure(0, weight=1)
        menu_frame.grid_columnconfigure(1,weight=1)

        tab_frame = Frame(master,pady=30)
        tab_frame.grid(row=1, column=0, sticky=(tk.N, tk.S, tk.E, tk.W))
        tab_frame.configure(bg=self.COLOR_frames)
        tab_frame.grid_columnconfigure(0, weight=1)
        tab_frame.grid_rowconfigure(0, weight=1)
        
        log_frame = Frame(master)
        log_frame.grid(row=2, column=0, sticky=(tk.N, tk.S, tk.E, tk.W))
        log_frame.configure(bg=self.COLOR_frames)
        log_frame.grid_columnconfigure(0, weight=1)
        

        prova = Image.open("icons/open.png")
        open_icon = ImageTk.PhotoImage(prova)
        render_icon = PhotoImage(file="icons/render.png")
        prod_icon = PhotoImage(file="icons/product.png")
        sync_icon = PhotoImage(file="icons/sync.png")
        proj_icon = PhotoImage(file="icons/projection.png")

        menu_bar = Menu(master)
        file_menu = Menu(menu_bar,tearoff=False)
        file_menu.add_command(label="Open",compound=tk.LEFT,command= lambda: self.open_file(None))
        file_menu.add_command(label="Open Saved Tabs",command=self.v_restoreSession)
        menu_bar.add_cascade(label="File",menu=file_menu)

        trasformation_menu = Menu(menu_bar,tearoff=False)
        trasformation_menu.add_command(label="Product",compound=tk.LEFT,command=self.open_product_view)
        trasformation_menu.add_command(label="Sync",compound=tk.LEFT,command=self.open_sync_view)
        trasformation_menu.add_command(label="Projection",compound=tk.LEFT,command=self.open_proj_view)
        menu_bar.add_cascade(label="Trasformations",menu=trasformation_menu)

        help_menu = Menu(menu_bar,tearoff=False)
        help_menu.add_command(label="ReadMe",compound=tk.LEFT,command=self.help_window)
        menu_bar.add_cascade(label="Help", menu= help_menu)

        self.master.config(menu=menu_bar)
        
        # create the log box
        self._log = Listbox(log_frame, highlightthickness=0, height=1, background=self.COLOR_log,
                            foreground=self.COLOR_foreground)
       
        self._log.pack(side="bottom", fill="x",padx=5,pady=5)

        self.tabs = ttk.Notebook(tab_frame)


    def open_file(self,path):

        if path == None:
        	path = filedialog.askopenfilename(initialdir=".",
        		                              filetypes=(("DOT graph", "*.gv *.dot"),
        		                              	         ("Chorgram grammar", "*.txt"), ("all files", "*.*")),
        		                              title="Choose a file."
        		                              )
        self.dos2unix(path)
        msg_result = []
        # Check in case user enter an unknown file
        # or closes without choosing a file.
        try:
            path_splitted = os.path.split(path)
            ext = path_splitted[1].split('.')
            # Chorgram file
            if ext[1] == 'txt':
                msg_result = self.__open_chorgram_file(path)
            # DOT files
            elif ext[1] == 'dot' or ext[1] == 'gv':
                msg_result = self.__open_dot_file__(path)
            else:
                self.popupmsg("Unknown extension file")
            # update log box
            self.log(msg_result)
        except:
            pass

    def __open_chorgram_file(self, path):
        path_splitted = os.path.split(path)
        # ask where store the converted dot file
        ask_for_path: bool = messagebox.askyesno("Chorgram", "A Chorgram file was inserted\n" +
                                                 "Do you wish to save the converted dot file in " +
                                                 path_splitted[0] + "?\n" +
                                                 "(Click NO to choose a new path)")
        if ask_for_path:  # Yes, use same path
            # (input path, path to store)
            msg_result, graph_name = self.controller.GGparser(path, path_splitted[0])
        else:
            new_folder = filedialog.askdirectory()
            msg_result, graph_name = self.controller.GGparser(path, new_folder)
        self.__add_new_tab__(graph_name,path)
        return msg_result
    
    def __open_dot_file__(self, path):
        # result[0] domitilla boolean
        # result[1] a message
        # result[2] graph name
        result = self.controller.DOTparser(path)
        msg_result = result[1]
        if result[0]:  # if a domitilla graph was founded
            # ask where store the converted dot file
            path_splitted = os.path.split(path)
            ask_for_path: bool = messagebox.askyesno("Domitilla", "A Domitilla file was inserted\n"
                                                                  "Do you wish to store the converted file in " +
                                                     path_splitted[0] + "?\n"
                                                                        "(Click NO to choose a new path)")
            if ask_for_path:  # Yes, use same path
                msg_result.append(
                    self.controller.DomitillaConverter(result[2], path,
                                                       path_splitted[0]))  # (graph name, input path, path to store)
            else:
                new_folder = filedialog.askdirectory()
                msg_result.append(self.controller.DomitillaConverter(result[2], path, new_folder))
        if len(result) > 2:  # case NO-errors detected
            # add a new tab for the new graph just opened
            self.__add_new_tab__(result[2],path)
        return msg_result
    
    def open_render_view(self):
        try:
            path = filedialog.askopenfilename(initialdir=".", filetypes=(("DOT graph", "*.gv *.dot"),
                                                                         ("all files", "*.*")), title="Choose a file.")
            path_splitted = os.path.split(path)
            ext = path_splitted[1].split('.')
            # Check in case user enter an unknown file
            # or closes without choosing a file.
            if ext[1] != 'dot' and ext[1] != 'gv':
                self.popupmsg("Wrong extension file inserted!\n"
                              "Please insert a DOT file")
            else:
                # define the frame and its geometry
                r_window = tk.Toplevel(padx=20, pady=20, bg=self.COLOR_frames)
                r_window.wm_title("Render")
                r_window.resizable(False, False)
                self.__set_window_dimension__(r_window)
                label_format = tk.Label(r_window, text="Choose a file format for render:", fg=self.COLOR_foreground,
                                        bg=self.COLOR_frames, wraplength=500)
                label_format.grid(row=0, column=0)
                
                # Initialize file format variable for radiobutton
                option = tk.StringVar()
                # Radiobutton
                rb1 = Radiobutton(r_window, text='png', value="png", var=option, bg=self.COLOR_frames)
                rb2 = Radiobutton(r_window, text='pdf', value="pdf", var=option, bg=self.COLOR_frames)
                rb1.grid(row=1, column=0)
                rb2.grid(row=1, column=1)
                # TODO try except for wrong dot files
                b = Button(r_window, text='Render', bg=self.COLOR_buttons,
                           command=lambda: (self.log(["[RENDER] " + self.controller.render(path, option.get(),True)]),
                                            r_window.destroy()))
                b.grid(row=2, column=1)
        except:
            pass
    
    def open_product_view(self):
        # define the frame and its geometry
        p_window = tk.Toplevel(padx=20, pady=20, bg=self.COLOR_frames)
        p_window.wm_title("Product")
        p_window.resizable(False, False)
        # set window dimension
        self.__set_window_dimension__(p_window)
        
        # label and combo for 1st graph
        lbl1 = tk.Label(p_window, text="Choose 1st Graph", bg=self.COLOR_frames, fg=self.COLOR_foreground)
        lbl1.grid(row=0, column=0, pady=10)
        combo1 = ttk.Combobox(p_window, values=list(self.controller.get_all_ca().keys()))
        combo1.grid(row=0, column=1, pady=10)
        
        # label and combo for 2st graph
        lbl2 = tk.Label(p_window, text="Choose 2st Graph", bg=self.COLOR_frames, fg='white')
        lbl2.grid(row=1, column=0, pady=10)
        combo2 = ttk.Combobox(p_window, values=list(self.controller.get_all_ca().keys()))
        combo2.grid(row=1, column=1, pady=10)
        
        make_button = Button(p_window, text='Make product', bg=self.COLOR_buttons,
                             command=lambda:
                             (self.__exec_product_button__(combo1.get(), combo2.get()),
                              p_window.destroy()))
        make_button.grid(row=2, column=0, pady=10)
    
    def open_sync_view(self):
        s_window = tk.Toplevel(padx=20, pady=20, bg=self.COLOR_frames)
        s_window.wm_title("Synchronisation")
        s_window.resizable(False, False)
        # set window dimension
        self.__set_window_dimension__(s_window)
        
        # label and combo for the graph to synchronize
        lbl1 = tk.Label(s_window, text="Choose Graph", fg='white', bg=self.COLOR_frames)
        lbl1.grid(row=0, column=0, padx=10, pady=10)
        option_v1 = tk.StringVar()
        option_v2 = tk.StringVar()
        combo = ttk.Combobox(s_window, values=list(self.controller.get_all_ca().keys()))
        combo.bind("<<ComboboxSelected>>", lambda event: self.__make_sync_interface_menu__(s_window, list(
            self.controller.get_participants(combo.get())), option_v1, option_v2))
        combo.grid(row=1, column=0, padx=10, pady=10)
        
        sync_button = Button(s_window, text='Synchronize', bg=self.COLOR_buttons,
                             command=lambda: (
                                 self.__exec_sync_button__(combo.get(), option_v1.get(), option_v2.get()),
                                 s_window.destroy()))
        
        sync_button.grid(row=4, column=0)
    
    def open_proj_view(self):
        proj_window = tk.Toplevel(padx=20, pady=20, bg=self.COLOR_frames)
        proj_window.wm_title("Projection")
        proj_window.resizable(False, False)
        
        # set window dimension
        self.__set_window_dimension__(proj_window)
        
        # label and combo for the graph to synchronize
        lbl1 = tk.Label(proj_window, text="Choose Graph", bg=self.COLOR_frames, fg='white')
        lbl1.grid(row=0, column=0, padx=10, pady=10)
        
        option = tk.StringVar()
        combo = ttk.Combobox(proj_window, values=list(self.controller.get_all_ca().keys()))
        combo.bind("<<ComboboxSelected>>", lambda event: self.__make_proj_participant_menu__(proj_window, list(
            self.controller.get_participants(combo.get())), option))
        combo.grid(row=1, column=0, padx=10, pady=10)
        
        proj_button = Button(proj_window, text='Project', bg=self.COLOR_buttons,
                             command=lambda: (
                                 self.__exec_proj_button__(combo.get(), option.get()),
                                 proj_window.destroy()))
        
        proj_button.grid(row=4, column=0)
    
    def __add_new_tab__(self, graph_name,v_path):
        self.tabs.grid(row=0, column=0, sticky=(tk.N, tk.S, tk.E, tk.W), padx=10, pady=5)
        frame = ttk.Frame(self.tabs)
        frame.grid_columnconfigure(4, weight=1)
        #frame.grid_columnconfigure(0, weight=2)
        #frame.grid_rowconfigure(1, weight=2)

        # Add the tab
        self.tabs.add(frame, text=graph_name)

        label_s = tk.Label(frame, text = "N° States:",wraplength=500,bg=self.COLOR_frames,fg=self.COLOR_foreground)
        label_s.grid(row=0,column=0,pady=10,padx=20)

        entry_s = tk.Label(frame, text=(str(len(self.controller.get_states(graph_name)))),wraplength=500,bg=self.COLOR_frames,fg=self.COLOR_foreground)
        entry_s.grid(row=0,column=1,pady=10,padx=20)

        label_e = tk.Label(frame, text="N° Edges:", wraplength=500, bg=self.COLOR_frames, fg=self.COLOR_foreground)
        label_e.grid(row=1, column=0, pady=10, padx=20)

        entry_e = tk.Label(frame, text=str(len(self.controller.get_edges(graph_name))), wraplength=500, bg=self.COLOR_frames, fg=self.COLOR_foreground)
        entry_e.grid(row=1, column=1, pady=10, padx=20)

        label_sn = tk.Label(frame, text="Start Node:", wraplength=500, bg=self.COLOR_frames, fg=self.COLOR_foreground)
        label_sn.grid(row=2, column=0, pady=10, padx=20)

        entry_sn = tk.Label(frame, text=str(self.controller.get_start_node(graph_name)), wraplength=500, bg=self.COLOR_frames, fg=self.COLOR_foreground)
        entry_sn.grid(row=2, column=1, pady=10, padx=20)

        label_eps = tk.Label(frame, text="Epsilon moves:", wraplength=500, bg=self.COLOR_frames, fg=self.COLOR_foreground)
        label_eps.grid(row=5, column=0, pady=10, padx=20)

        entry_eps = tk.Label(frame, text=self.controller.check_for_epsilon_moves(graph_name), wraplength=500, bg=self.COLOR_frames, fg=self.COLOR_foreground)
        entry_eps.grid(row=5, column=1, pady=10, padx=20)

        label_l = tk.Label(frame, text="N° Labels:", wraplength=500, bg=self.COLOR_frames, fg=self.COLOR_foreground)
        label_l.grid(row=3, column=0, pady=10, padx=20)
        
        elements_l = list(self.controller.get_labels(graph_name))
        option_l = tk.StringVar()
        option_l.set(elements_l[0])

        label_menu = ttk.OptionMenu(frame, option_l, elements_l[0], *elements_l)
        label_menu.grid(row=3, column=2, pady=10, padx=20)

        entry_l = tk.Label(frame, text = len(elements_l), wraplength=500, bg=self.COLOR_frames, fg=self.COLOR_foreground)
        entry_l.grid(row=3, column=1, pady=10, padx=20)

        label_p = tk.Label(frame, text="N° Participants:", wraplength=500, bg=self.COLOR_frames, fg=self.COLOR_foreground)
        label_p.grid(row=4, column=0, pady=10, padx=20)

        elements_p = list(self.controller.get_participants(graph_name))
        option_p = tk.StringVar()
        option_p.set(elements_p[0])

        part_menu = ttk.OptionMenu(frame, option_p, elements_p[0], *elements_p)
        part_menu.grid(row=4, column=2, pady=10, padx=20)

        entry_p = tk.Label(frame, text=len(elements_p), wraplength=500, bg=self.COLOR_frames, fg=self.COLOR_foreground)
        entry_p.grid(row=4, column=1, pady=10, padx=20)

        self.controller.render(v_path,'png',False)
        new_path = v_path + ".png"
        image = Image.open(new_path)
        image = image.resize((150,200), Image.ANTIALIAS)
        img = ImageTk.PhotoImage(image)
        labelprova = tk.Label(frame,image=img)
        labelprova.photo=img
        labelprova.grid(row=0,column=3,rowspan=5,padx=10,pady=10,sticky=tk.W) 

		# create close button
        close_button = Button(frame, text='X', bg=self.COLOR_frames, highlightthickness=0, borderwidth=0, command=lambda: (
            self.controller.remove_record(self.tabs.tab(self.tabs.select(), "text")),
            # remove the record from opened graphs struct
            self.tabs.forget(self.tabs.select()),
            self.tabs_history.remove(v_path)))  # delete the tab
        close_button.grid(row=0, column=4, sticky=tk.E + tk.N)
        
        #update tab in tab history
        self.tabs_history.append(v_path)
        # once created, select the tab
        self.tabs.select(frame)
    
    def __exec_sync_button__(self, combo_value, interface1, interface2):
        path_to_store = filedialog.asksaveasfilename(initialdir=".", title="Save as",
                                                     filetypes=("DOT graph", "*.gv *.dot"))
        result= self.controller.synchronize(combo_value, interface1, interface2, path_to_store)
        # print the log message
        self.log(result[0])
        # create a new tab for the product graph
        self.open_file(path_to_store+".gv")
    
    def __exec_product_button__(self, combo_value1, combo_value2):
        path_to_store = filedialog.asksaveasfilename(initialdir=".", title="Save as",
                                                     filetypes=("DOT graph", "*.gv *.dot"))
        result = self.controller.make_product(combo_value1, combo_value2, path_to_store)
        # print the log message
        self.log(result[0])
        # create a new tab for the product graph
        self.open_file(path_to_store+".gv")
    
    def __exec_proj_button__(self, combo_value, participant):
        path_to_store = filedialog.asksaveasfilename(initialdir=".", title="Save as",
                                                     filetypes=("DOT graph", "*.gv *.dot"))
        result = self.controller.projection(combo_value, participant, path_to_store)

        self.open_file(path_to_store+".gv")

        # print the log message
        self.log(result[0])

    
    def __make_sync_interface_menu__(self, frame, elements, option_v1, option_v2):
        # label and optionMenu for the 1st interface
        option_v1.set(elements[0])
        lbl2 = tk.Label(frame, text="Select 1st participant", bg=self.COLOR_frames, fg=self.COLOR_foreground)
        lbl2.grid(row=2, column=0, padx=10, pady=10)
        op_menu_1 = ttk.OptionMenu(frame, option_v1, elements[0], *elements)
        op_menu_1.grid(row=2, column=1, padx=10, pady=10)
        
        # label and optionMenu for the 2st interface
        option_v2.set(elements[0])
        lbl3 = tk.Label(frame, text='Select 2st participant', bg=self.COLOR_frames, fg=self.COLOR_foreground)
        lbl3.grid(row=3, column=0, pady=10)
        op_menu_2 = ttk.OptionMenu(frame, option_v2, elements[0], *elements)
        op_menu_2.grid(row=3, column=1, padx=10, pady=10)
        
        # update window dimension
        self.__set_window_dimension__(frame)
    
    def __make_proj_participant_menu__(self, frame, elements, option):
        option.set(elements[0])
        lbl = tk.Label(frame, text='Select participant to project', bg=self.COLOR_frames, fg=self.COLOR_foreground)
        lbl.grid(row=2, column=0, padx=10, pady=10)
        op_menu = ttk.OptionMenu(frame, option, elements[0], *elements)
        op_menu.grid(row=2, column=1, padx=10, pady=10)
        self.__set_window_dimension__(frame)
    
    def __set_window_dimension__(self, frame):
        # set window dimension
        width, height = frame.winfo_reqwidth(), frame.winfo_reqheight()
        frame.geometry('+%d+%d' % (self._screen_width / 2 - width / 2, self._screen_height / 2 - height / 2))
        
    def log(self, msg):
        print(msg)
        # Write a message in the log box
        for line in msg:
            self._log.insert(tk.END, line)
        self._log.see(tk.END)
        # make the last item background red
        #self._log.itemconfig(tk.END, {'bg': 'red'})
    
    def popupmsg(self, msg):
        popup = tk.Toplevel(padx=20, pady=20)
        popup.wm_title("!")
        popup.resizable(False, False)
        
        screen_width, screen_height = popup.winfo_screenwidth(), popup.winfo_screenheight()
        width, height = popup.winfo_reqwidth(), popup.winfo_reqheight()
        
        popup.geometry('+%d+%d' % (screen_width / 2 - width / 2, screen_height / 2 - height / 2))
        
        max_size = popup.winfo_screenwidth() / 3
        label = tk.Label(popup, text=msg, wraplength=max_size)
        label.grid(row=0, column=0)
        
        b = ttk.Button(popup, text="Okay", command=popup.destroy)
        b.grid(row=1, column=0)